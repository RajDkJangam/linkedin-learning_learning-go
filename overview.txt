Go's essential characteristics
Here are some of the most important things to understand about the Go programming language. One of the first questions programmers frequently ask is whether a language is compiled or interpreted. An example of an interpreted language is JavaScript. JavaScript source code is read directly by the browser and then executed all at run time. There is no precompilation step. And while in some interpreted environments, there's an intermediate format, such as bytecode, there is no precompilation step that you have to follow.
A compiled language, in contrast, is transformed into a format that's specific to an operating system. C and C++ are both compiled languages. Go is a compiled language, it's compiled to a form that can only run on a single operating system. And it's also statically typed which means that its variables have specific types. You don't always have to explicitly declare the types, they're sometimes inferred by the compiler but they're always known at compilation time.
It can sometimes feel with Go like you're working with an interpreted language because you can run a source code file without precompiling. But what's really happening in the background is that the application is being compiled to a temporary executable. When you're creating applications that you're going to deliver to users, though, you'll always use the compilation tool known simply as Go. And as I mentioned, the resulting compiled executable will always be operating system specific.
So if you compile on Windows, that executable can only run on Windows. If you compile on Mac, it can run on Mac and so on. Applications built with Go have a statically linked runtime. That is, there's a runtime component that's built in to the application during the compilation process. You'll see early in the course that the size of a compiled application is much larger than its source code file and that's because this runtime is being included.
But there is no external virtual machine. So, for example, in Java, you have an operating system specific virtual machine, or VM, that's expected to be installed on the client and therefore the Java application, which is compiled into bytecode, can be very, very small. With Go, there is no external virtual machine and so the runtime has to be statically linked into every application. Another question that's frequently asked is whether a language is object oriented.
And the answer with Go is, "Yes, sort of." It implements some critical object oriented features. For example, you can define your own interfaces. An interface is a contract of sorts that defines a set of functions and then something that implements that interface has to implement those functions. In Go, you define types. Almost everything is a type in Go and every type implements at least one interface.
When you add functions to a type, they're now called methods and that's an object oriented term. You can create your own data structures in Go and those can have member fields. So the types and structures of Go can feel a lot like the classes in a language such as Java or C#. But there's a lot of features in those languages that aren't present in Go. For example, there's no type inheritance in Go. You can't create a type and say, "That's the supertype," and then create something called a subtype and inherit features from the supertype.
That's just not a part of the Go architecture. There's also no method or operator overloading. Each function or method within a package or type in Go has a specific signature. That is, a set of arguments that you can pass in and a data type you can pass back or return. But you can't have more than one function in a package or more than one method in a type that has the same name. Also, the Go language doesn't have structured exception handling, such as you might expect in a language like Java or C#.
There is no try, catch, or finally, key words. Instead, error objects are simply returned by functions which might have those errors and then you use conditional logic to examine the error objects. There's also no implicit numeric conversions. You have to explicitly type every variable or implicitly type it by saying exactly where you're getting the data. But either way, if you want to convert a value from one type to another in Go, you have to do it explicitly by wrapping the value in a function that says, "I want it to be this type." The main reason you won't find these language features in Go is because the language's designers felt that these features, which are common to very advanced languages, make these languages harder to read and more susceptible to bugs.
You'll find that everything you need to know about a Go program is there on the surface. You don't have to remember a rule of the language because it's all there in the application's code. Go is based on a number of different languages. It was designed as a next generation language that could do everything you can do with C. Systems programming, application programming, and so on. So it borrows a lot of syntax from C and its related languages, C++, C#, Java, and so on.
But it also borrows syntax from Pascal, Modula, Oberon and other similar languages. One of the most important things it tries to do is reduce the amount of typing you have to do as a programmer. You'll see that Go programming is very concise and there aren't a lot of unnecessary characters to get in the way. Here are some critical syntax rules in Go. Go is case sensitive so identifiers, such as method, and variable names have to be spelled exactly the way you see them in the documentation.
Case sensitivity is an interesting thing in Go, you'll see that most variables and package names are lower and mixed case. But when you're working with functions and methods, and fields, which are variables that are members of types, you'll see that the frequently have initial uppercase characters. That has a special meaning in Go. An initial uppercase character means that a field or a method is available to the rest of the application. It's the equivalent of the public keyword in other languages and a lower case initial character means that it's not available to the rest of the application.
Again, Go tries to reduce the amount of typing you have to do as a developer and one of the ways it does this is to eliminate the semicolons that you find at the end of a statement in most C style languages. This bit of code is declaring a variable, an array of strings, and then setting the values of the items in the array. Notice there is no semicolon at the end of each statement. Interestingly, the language specification says the semicolons are supposed to be there but the lexer, that is, the bit of software that analyzes your code, adds them during the compilation process as needed.
There's a fairly simple rule that dictates when the semicolons are added for you. If a statement is complete and the lexer encounters a line feed, that means it's the end of the statement and you don't need to add the semicolon yourself. But that also means that you can't always add line feeds freely as you might do in other languages because in certain circumstances, they can be misinterpreted by the lexer. As with other C style languages, code blocks, that is, multiple lines of code that are intended to be grouped together, are wrapped with brace characters.
Here's an example. In a for statement, the code that you want to iterate over is wrapped between the two braces. Now, because of the rules of how the lexer analyzes new lines, the first brace in a code block must be on the same line as any preceding statement. Unlike other C style languages, that aren't sensitive to white space, in Go, you don't have the freedom to drop the beginning brace down to the next blank line. Other than that, this code looks very much like C and other similar languages.
You'll also notice, though, that parentheses aren't always needed. This for statement, which is similar to C and Java, doesn't have parentheses around the three elements, the setting of the counter variable, the condition, and the incrementing statement. Again, Go eliminates unnessecary punctuation. And finally, here are some other critical characteristics. Go has a set of built-in functions that are always available in your code without specifically having to import anything.
These functions are member of a special package named builtin. But the Go compilier assumes that that builtin package is always imported. You'll find functions like len for length, panic to stop execution and display an error message, and recover. You can find out about everything in the builtin package at the URL you see on the screen. So that's a high level overview of some of the most important things to know about Go. Now, let's step to how you can actually do some Go programming.ou can actually do some Go programming.ou can actually do some Go programming.